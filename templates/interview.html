<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview - MockFlow-AI</title>
    <link rel="icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/interview.css">
</head>
<body>
    <div class="interview-page">
        <div class="state-flash" id="stateFlash"></div>
        
        <!-- Progress Header -->
        <header class="progress-header">
            <div class="progress-container">
                <div class="progress-stages">
                    <div class="progress-line">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    
                    <div class="stage-dot active" data-stage="welcome" id="stageWelcome">
                        <div class="stage-circle">1</div>
                        <span class="stage-label">Welcome</span>
                    </div>
                    
                    <div class="stage-dot" data-stage="self_intro" id="stageSelfIntro">
                        <div class="stage-circle">2</div>
                        <span class="stage-label">Introduction</span>
                    </div>
                    
                    <div class="stage-dot" data-stage="past_experience" id="stagePastExp">
                        <div class="stage-circle">3</div>
                        <span class="stage-label">Experience</span>
                    </div>
                    
                    <div class="stage-dot" data-stage="company_fit" id="stageCompanyFit">
                        <div class="stage-circle">4</div>
                        <span class="stage-label">Company Fit</span>
                    </div>
                    
                    <div class="stage-dot" data-stage="closing" id="stageClosing">
                        <div class="stage-circle">5</div>
                        <span class="stage-label">Closing</span>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Skip area: compact toggle below timer (buttons revealed on toggle) -->
        
        <!-- Connection Status -->
        <div class="connection-status" id="connectionStatus">
            <span class="status-indicator connecting" id="statusIndicator"></span>
            <span id="statusText">Connecting...</span>
        </div>
        
        <div class="stage-timer-display" id="stageTimer">0:00</div>
        <div class="skip-area">
            <button id="skipToggle" class="skip-toggle" aria-expanded="false">Skip stages ▾</button>
            <div class="skip-row hidden" id="skipRow">
                <button class="skip-btn current" data-target="self_intro" disabled id="skipSelfIntro">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Intro
                    <span class="skip-tooltip">Skip to Introduction</span>
                </button>
                <button class="skip-btn" data-target="past_experience" id="skipPastExp">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Experience
                    <span class="skip-tooltip">Skip to Experience</span>
                </button>
                <button class="skip-btn" data-target="company_fit" id="skipCompanyFit">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Company Fit
                    <span class="skip-tooltip">Skip to Company Fit</span>
                </button>
                <button class="skip-btn" data-target="closing" id="skipClosing">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Closing
                    <span class="skip-tooltip">Skip to Closing</span>
                </button>
            </div>
        </div>
        
        <!-- Main Interview Area -->
        <main class="interview-main">
            <div class="agent-side">
                <span class="agent-label">AI Interviewer</span>
                <div class="agent-visualizer" id="agentVisualizer">
                    <div class="voice-circle">
                        <div class="voice-circle-bg"></div>
                        <div class="bars-container" id="agentBarsContainer"></div>
                        <div class="agent-eyes" id="agentEyes">
                            <div class="agent-eye"></div>
                            <div class="agent-eye"></div>
                        </div>
                    </div>
                </div>
                <div class="agent-caption">
                    <p class="caption-text empty" id="agentCaption">Waiting for agent...</p>
                </div>
            </div>
            
            <div class="candidate-side">
                <span class="candidate-label">Candidate</span>
                <div class="candidate-card">
                    <div class="candidate-video-container" id="videoContainer">
                        <video class="candidate-video" id="candidateVideo" autoplay muted playsinline></video>
                        <div class="video-placeholder">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                                <circle cx="9" cy="7" r="4"/>
                            </svg>
                            <span>Camera Off</span>
                        </div>
                        <button class="video-toggle" id="videoToggle" title="Toggle Camera">
                            <svg class="icon-on" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M23 7l-7 5 7 5V7z"/>
                                <rect x="1" y="5" width="15" height="14" rx="2"/>
                            </svg>
                            <svg class="icon-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"/>
                                <line x1="1" y1="1" x2="23" y2="23"/>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="candidate-info-row">
                        <div class="candidate-info-top">
                            <h3 class="candidate-name" id="candidateName">Loading...</h3>
                            <p class="candidate-role" id="candidateRole">-</p>
                        </div>
                        <div class="candidate-meta">
                            <span class="candidate-level" id="candidateLevel">-</span>
                        </div>
                    </div>
                    
                    <div class="audio-spikes-box" id="audioSpikesBox">
                        <div class="spikes-container" id="spikesContainer"></div>
                        <div class="noise-warning" id="noiseWarning">
                            <p class="noise-warning-text">High background noise detected.</p>
                        </div>
                    </div>
                </div>
                
                <div class="candidate-caption">
                    <p class="caption-text empty" id="candidateCaption">Initiating...</p>
                </div>
            </div>
        </main>
        
        <!-- Controls -->
        <div class="interview-controls">
            <button class="btn-icon" id="muteBtn" title="Mute/Unmute">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="muteIcon">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                    <line x1="8" y1="23" x2="16" y2="23"/>
                </svg>
            </button>
            <button class="btn-danger" id="endBtn">End Interview</button>
        </div>
        
        <!-- Modal -->
        <div class="modal-overlay" id="modalOverlay">
            <div class="modal-content">
                <div class="modal-icon warning" id="modalIcon">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                </div>
                <h3 class="modal-title" id="modalTitle">End Interview?</h3>
                <p class="modal-message" id="modalMessage">Are you sure you want to end the interview?</p>
                <div class="modal-actions" id="modalActions">
                    <button class="btn-secondary" id="modalCancel">Cancel</button>
                    <button class="btn-danger" id="modalConfirm">End Interview</button>
                </div>
                <!-- Feedback button (shown after interview ends) -->
                <div class="modal-feedback-actions" id="modalFeedbackActions" style="display: none;">
                    <button class="btn-feedback-golden" id="getFeedbackBtn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/>
                        </svg>
                        Get Feedback
                    </button>
                    <button class="btn-secondary" id="returnHomeBtn">Return Home</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/livekit-client@2.5.0/dist/livekit-client.umd.min.js"></script>
    <script>
        if (typeof LivekitClient === 'undefined' && typeof LiveKit === 'undefined') {
            document.write('<script src="https://unpkg.com/livekit-client@2.5.0/dist/livekit-client.umd.min.js"><\/script>');
        }
    </script>

    <script>
    (function() {
        'use strict';

        window.addEventListener('load', initInterview);

        function initInterview() {
            var LK = null;
            var LIVEKIT_CDN = 'https://cdn.jsdelivr.net/npm/livekit-client@2.5.0/dist/livekit-client.umd.min.js';
            var statusEl = document.getElementById('statusText');

            function getLKGlobal() {
                return window.LivekitClient || window.LiveKit || window.LiveKitClient || window.livekit || null;
            }

            function loadScript(src) {
                return new Promise(function(resolve, reject) {
                    var s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = function() { resolve(); };
                    s.onerror = function() { reject(new Error('Failed to load ' + src)); };
                    document.head.appendChild(s);
                });
            }

            async function ensureLivekitLoaded() {
                LK = getLKGlobal();
                if (LK) return LK;
                if (statusEl) statusEl.textContent = 'Loading LiveKit client...';

                // Try a local vendor copy first (faster and avoids CDN issues)
                var localPath = '/static/vendors/livekit-client.umd.min.js';
                try {
                    await loadScript(localPath);
                    LK = getLKGlobal();
                    if (LK) {
                        if (statusEl) statusEl.textContent = 'Loaded local LiveKit client';
                        return LK;
                    }
                    // If local file present but global not exposed, fall through to CDN
                } catch (localErr) {
                    // local fallback not available — continue to CDN
                    console.debug('[LIVEKIT] Local vendor not available:', localErr);
                }

                // Try CDN next
                try {
                    await loadScript(LIVEKIT_CDN);
                    LK = getLKGlobal();
                    if (LK) return LK;
                    throw new Error('LiveKit client did not expose expected globals');
                } catch (err) {
                    if (statusEl) statusEl.textContent = 'Failed to load libraries';

                    // Build a visible error box with actions and details
                    var existingError = document.getElementById('livekitErrorBox');
                    if (!existingError) {
                        var errorBox = document.createElement('div');
                        errorBox.id = 'livekitErrorBox';
                        errorBox.className = 'livekit-error';
                        errorBox.innerHTML = '<div><strong>LiveKit client failed to load.</strong></div>';

                        var actions = document.createElement('div');
                        actions.className = 'livekit-actions';

                        var retry = document.createElement('button');
                        retry.id = 'retryLivekitBtn';
                        retry.className = 'btn';
                        retry.textContent = 'Retry';

                        var localBtn = document.createElement('button');
                        localBtn.id = 'useLocalLivekitBtn';
                        localBtn.className = 'btn';
                        localBtn.textContent = 'Use local LiveKit client';

                        actions.appendChild(retry);
                        actions.appendChild(localBtn);
                        errorBox.appendChild(actions);

                        var details = document.createElement('pre');
                        details.id = 'livekitErrorDetails';
                        details.className = 'livekit-details';
                        details.textContent = String(err && err.message ? err.message : err);
                        errorBox.appendChild(details);

                        if (statusEl && statusEl.parentNode) statusEl.parentNode.appendChild(errorBox);

                        // Retry handler — attempts CDN again
                        retry.addEventListener('click', function(e) {
                            e.stopPropagation();
                            retry.disabled = true;
                            details.textContent = 'Retrying...';
                            if (statusEl) statusEl.textContent = 'Retrying...';
                            ensureLivekitLoaded().then(function() {
                                try { errorBox.remove(); } catch (e) {}
                                startAfterLivekit();
                            }).catch(function(e2) {
                                console.error('[LIVEKIT] Retry failed', e2);
                                retry.disabled = false;
                                details.textContent = String(e2 && e2.message ? e2.message : e2);
                                if (statusEl) statusEl.textContent = 'Retry failed';
                            });
                        });

                        // Local fallback handler: try loading from /static/vendors/
                        localBtn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            localBtn.disabled = true;
                            details.textContent = 'Attempting local fallback...';
                            if (statusEl) statusEl.textContent = 'Attempting local fallback...';
                            loadScript(localPath).then(function() {
                                LK = getLKGlobal();
                                if (LK) {
                                    try { errorBox.remove(); } catch (e) {}
                                    if (statusEl) statusEl.textContent = 'Loaded local LiveKit client';
                                    startAfterLivekit();
                                    return;
                                }
                                throw new Error('Local file loaded but LiveKit global not found');
                            }).catch(function(e2) {
                                console.error('[LIVEKIT] Local fallback failed', e2);
                                localBtn.disabled = false;
                                details.textContent = String(e2 && e2.message ? e2.message : e2) + '\n\nTip: Place a copy of the LiveKit client at /static/vendors/livekit-client.umd.min.js to enable local fallback.';
                                if (statusEl) statusEl.textContent = 'Local fallback failed';
                            });
                        });
                    }
                    console.error('[LIVEKIT] Could not load client:', err);
                    throw err;
                }
            }
            
            var params = new URLSearchParams(window.location.search);
            var candidate = {
                name: params.get('name') || 'Candidate',
                email: params.get('email') || '',
                role: params.get('role') || 'Position',
                level: params.get('level') || 'entry',
                resumeCacheKey: params.get('resumeCacheKey') || '',
                includeProfile: params.get('includeProfile') !== 'false'
            };
            
            document.getElementById('candidateName').textContent = candidate.name;
            document.getElementById('candidateRole').textContent = candidate.role;
            document.getElementById('candidateLevel').textContent = formatLevel(candidate.level);
            
            var state = {
                currentStage: 'welcome',
                isMuted: false,
                isConnected: false,
                isVideoOn: true,
                room: null,
                audioContext: null,
                analyser: null,
                interviewStartTime: Date.now(),
                blinkInterval: null,
                timerInterval: null,
                agentAudioAnalyser: null,
                agentAudioContext: null,
                roomName: null,
                interviewFilename: null
            };
            
            var elements = {
                statusIndicator: document.getElementById('statusIndicator'),
                statusText: document.getElementById('statusText'),
                agentBarsContainer: document.getElementById('agentBarsContainer'),
                agentEyes: document.getElementById('agentEyes'),
                agentCaption: document.getElementById('agentCaption'),
                candidateCaption: document.getElementById('candidateCaption'),
                spikesContainer: document.getElementById('spikesContainer'),
                stageTimer: document.getElementById('stageTimer'),
                progressFill: document.getElementById('progressFill'),
                stateFlash: document.getElementById('stateFlash'),
                muteBtn: document.getElementById('muteBtn'),
                muteIcon: document.getElementById('muteIcon'),
                endBtn: document.getElementById('endBtn'),
                modalOverlay: document.getElementById('modalOverlay'),
                modalCancel: document.getElementById('modalCancel'),
                modalConfirm: document.getElementById('modalConfirm'),
                videoContainer: document.getElementById('videoContainer'),
                candidateVideo: document.getElementById('candidateVideo'),
                videoToggle: document.getElementById('videoToggle')
            };
            
            var stages = ['welcome', 'self_intro', 'past_experience', 'company_fit', 'closing'];
            var stageProgress = { welcome: 0, self_intro: 20, past_experience: 40, company_fit: 60, closing: 100 };
            
            var AGENT_BAR_COUNT = 64;
            var agentBars = [];
            var agentBarHeights = new Array(AGENT_BAR_COUNT).fill(4);
            
            var SPIKE_COUNT = 50;
            var spikeHeights = new Array(SPIKE_COUNT).fill(3);

            // Demo animation IDs
            var demoAgentAnimationId = null;
            var demoCandidateAnimationId = null;

            initAgentVisualizer();
            initCandidateSpikes();
            initVideoFeed();
            initSkipControls();
            startTimer();
            startBlinkAnimation();
            startDemoAnimations();

            // Ensure LiveKit client is loaded before attempting to connect
            ensureLivekitLoaded().then(function() {
                try { connectToRoom(); } catch (e) { console.error('[CONNECT] start error', e); }
            }).catch(function(err) {
                console.warn('[LIVEKIT] Could not load client:', err);
            });
            
            elements.muteBtn.addEventListener('click', toggleMute);
            elements.endBtn.addEventListener('click', function() { showModal(); });
            elements.modalCancel.addEventListener('click', hideModal);
            elements.modalConfirm.addEventListener('click', confirmEndInterview);
            elements.videoToggle.addEventListener('click', toggleVideo);
            
            function formatLevel(level) {
                var levels = { entry: 'Entry Level', mid: 'Mid Level', senior: 'Senior Level' };
                return levels[level] || level;
            }
            
            function updateStatus(text, type) {
                elements.statusText.textContent = text;
                elements.statusIndicator.className = 'status-indicator ' + type;
            }
            
            function updateStage(newStage) {
                if (newStage === state.currentStage) return;

                state.currentStage = newStage;

                // Update progress header with data attribute for color theme
                var progressHeader = document.querySelector('.progress-header');
                if (progressHeader) {
                    progressHeader.setAttribute('data-current-stage', newStage);
                }

                elements.stateFlash.classList.add('active');
                setTimeout(function() { elements.stateFlash.classList.remove('active'); }, 600);

                elements.progressFill.style.width = stageProgress[newStage] + '%';

                stages.forEach(function(stage, index) {
                    var dot = document.querySelector('[data-stage="' + stage + '"]');
                    var currentIndex = stages.indexOf(newStage);

                    dot.classList.remove('active', 'completed');
                    if (index < currentIndex) {
                        dot.classList.add('completed');
                    } else if (index === currentIndex) {
                        dot.classList.add('active');
                    }
                });

                updateSkipButtons(newStage);
                console.log('[STAGE] Transition to:', newStage);
            }
            
            function initSkipControls() {
                var skipBtns = document.querySelectorAll('.skip-btn');
                var skipToggle = document.getElementById('skipToggle');
                var skipRow = document.getElementById('skipRow');

                skipBtns.forEach(function(btn) {
                    btn.addEventListener('click', function() {
                        var target = this.getAttribute('data-target');
                        if (!this.disabled && state.room) {
                            requestSkipStage(target);
                        }
                    });
                });

                if (skipToggle && skipRow) {
                    skipToggle.addEventListener('click', function(e) {
                        e.stopPropagation();
                        var open = skipRow.classList.toggle('open');
                        skipRow.classList.toggle('hidden', !open);
                        skipToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
                    });

                    // close when clicking outside the skip area
                    document.addEventListener('click', function(e) {
                        if (!skipRow.contains(e.target) && !skipToggle.contains(e.target)) {
                            skipRow.classList.add('hidden');
                            skipRow.classList.remove('open');
                            skipToggle.setAttribute('aria-expanded', 'false');
                        }
                    });
                }
            }
            
            function updateSkipButtons(currentStage) {
                var skipBtns = document.querySelectorAll('.skip-btn');
                var currentIndex = stages.indexOf(currentStage);
                
                skipBtns.forEach(function(btn) {
                    var target = btn.getAttribute('data-target');
                    var targetIndex = stages.indexOf(target);
                    
                    btn.classList.remove('current', 'completed');
                    
                    if (targetIndex < currentIndex) {
                        btn.classList.add('completed');
                        btn.disabled = true;
                    } else if (targetIndex === currentIndex) {
                        btn.classList.add('current');
                        btn.disabled = true;
                    } else {
                        btn.disabled = false;
                    }
                });
            }
            
            function requestSkipStage(targetStage) {
                if (!state.room || !state.room.localParticipant) {
                    console.error('[SKIP] No room connection');
                    return;
                }
                
                console.log('[SKIP] Requesting skip to:', targetStage);
                
                var payload = JSON.stringify({
                    type: 'skip_stage',
                    target_stage: targetStage
                });
                
                state.room.localParticipant.publishData(
                    new TextEncoder().encode(payload),
                    { reliable: true }
                ).then(function() {
                    console.log('[SKIP] Skip request sent');
                }).catch(function(err) {
                    console.error('[SKIP] Send error:', err);
                });
            }
            
            function startTimer() {
                state.timerInterval = setInterval(function() {
                    var elapsed = Math.floor((Date.now() - state.interviewStartTime) / 1000);
                    var minutes = Math.floor(elapsed / 60);
                    var seconds = elapsed % 60;
                    elements.stageTimer.textContent = minutes + ':' + seconds.toString().padStart(2, '0');
                }, 1000);
            }
            
            function initAgentVisualizer() {
                var container = elements.agentBarsContainer;
                container.innerHTML = '';
                agentBars = [];
                
                for (var i = 0; i < AGENT_BAR_COUNT; i++) {
                    var bar = document.createElement('div');
                    bar.className = 'agent-bar';
                    container.appendChild(bar);
                    agentBars.push(bar);
                }
                
                agentBars.forEach(function(bar, i) {
                    var angle = (i / AGENT_BAR_COUNT) * 360 - 90;
                    bar.style.transform = 'rotate(' + angle + 'deg) translateY(-75px)';
                });
            }
            
            function updateAgentVisualizer(audioData) {
                agentBars.forEach(function(bar, i) {
                    var value = (audioData[i] || 0) / 255;
                    var targetHeight = 4 + value * 35;
                    agentBarHeights[i] = agentBarHeights[i] * 0.4 + targetHeight * 0.6;
                    bar.style.height = Math.max(4, agentBarHeights[i]) + 'px';
                });
            }
            
            function startBlinkAnimation() {
                function blink() {
                    elements.agentEyes.classList.add('blinking');
                    setTimeout(function() {
                        elements.agentEyes.classList.remove('blinking');
                    }, 150);
                }
                
                function scheduleNextBlink() {
                    state.blinkInterval = setTimeout(function() {
                        blink();
                        scheduleNextBlink();
                    }, 2000 + Math.random() * 4000);
                }
                
                scheduleNextBlink();
            }

            // ==================== DEMO ANIMATIONS ====================

            function startDemoAnimations() {
                // Demo animation for agent circular visualizer
                var agentPhase = 0;
                function animateAgentDemo() {
                    if (state.agentAudioAnalyser) {
                        return; // Real audio connected, stop demo
                    }

                    var demoData = new Uint8Array(AGENT_BAR_COUNT);
                    for (var i = 0; i < AGENT_BAR_COUNT; i++) {
                        var wave = Math.sin((i / AGENT_BAR_COUNT) * Math.PI * 4 + agentPhase) * 0.3 + 0.25;
                        var noise = Math.random() * 0.15;
                        demoData[i] = (wave + noise) * 80;
                    }
                    agentPhase += 0.06;

                    updateAgentVisualizer(demoData);
                    demoAgentAnimationId = requestAnimationFrame(animateAgentDemo);
                }

                // Demo animation for candidate spikes
                var candidatePhase = 0;
                function animateCandidateDemo() {
                    if (state.analyser) {
                        return; // Real audio connected, stop demo
                    }

                    var demoData = new Uint8Array(SPIKE_COUNT);
                    for (var i = 0; i < SPIKE_COUNT; i++) {
                        var wave = Math.sin((i / SPIKE_COUNT) * Math.PI * 2 + candidatePhase) * 0.15 + 0.1;
                        var noise = Math.random() * 0.08;
                        demoData[i] = (wave + noise) * 35;
                    }
                    candidatePhase += 0.04;

                    updateCandidateSpikes(demoData);
                    demoCandidateAnimationId = requestAnimationFrame(animateCandidateDemo);
                }

                animateAgentDemo();
                animateCandidateDemo();
            }

            function stopDemoAnimations() {
                if (demoAgentAnimationId) {
                    cancelAnimationFrame(demoAgentAnimationId);
                    demoAgentAnimationId = null;
                }
                if (demoCandidateAnimationId) {
                    cancelAnimationFrame(demoCandidateAnimationId);
                    demoCandidateAnimationId = null;
                }
            }

            // ==================== CANDIDATE SPIKEY VISUALIZER ====================

            function initCandidateSpikes() {
                var container = elements.spikesContainer;
                container.innerHTML = '';

                for (var i = 0; i < SPIKE_COUNT; i++) {
                    var spike = document.createElement('div');
                    spike.className = 'spike-bar';
                    spike.style.height = '3px';
                    container.appendChild(spike);
                }
            }

            function updateCandidateSpikes(audioData) {
                var spikes = elements.spikesContainer.querySelectorAll('.spike-bar');

                spikes.forEach(function(spike, i) {
                    var value = audioData[i] || 0;
                    var normalized = value / 128;

                    var height = 3 + normalized * 35;

                    spikeHeights[i] = spikeHeights[i] * 0.6 + height * 0.4;
                    spike.style.height = Math.max(3, spikeHeights[i]) + 'px';
                });
            }
            
            function initVideoFeed() {
                navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                    .then(function(stream) {
                        elements.candidateVideo.srcObject = stream;
                    })
                    .catch(function(err) {
                        console.error('[VIDEO] Error:', err);
                        elements.videoContainer.classList.add('video-off');
                        state.isVideoOn = false;
                    });
            }
            
            function toggleVideo() {
                state.isVideoOn = !state.isVideoOn;
                
                if (state.isVideoOn) {
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(function(stream) {
                            elements.candidateVideo.srcObject = stream;
                            elements.videoContainer.classList.remove('video-off');
                            elements.videoToggle.classList.remove('off');
                        })
                        .catch(function(err) {
                            console.error('[VIDEO] Error:', err);
                            state.isVideoOn = false;
                        });
                } else {
                    var stream = elements.candidateVideo.srcObject;
                    if (stream) {
                        stream.getTracks().forEach(function(track) { track.stop(); });
                    }
                    elements.candidateVideo.srcObject = null;
                    elements.videoContainer.classList.add('video-off');
                    elements.videoToggle.classList.add('off');
                }
            }
            
            function updateAgentCaption(text) {
                if (!text) {
                    elements.agentCaption.textContent = '';
                    elements.agentCaption.classList.add('empty');
                    return;
                }
                elements.agentCaption.classList.remove('empty');
                elements.agentCaption.textContent = text;
            }
            
            function updateCandidateCaption(text) {
                if (!text) {
                    elements.candidateCaption.textContent = '';
                    elements.candidateCaption.classList.add('empty');
                    return;
                }
                elements.candidateCaption.classList.remove('empty');
                elements.candidateCaption.textContent = text;
            }
            
            function toggleMute() {
                state.isMuted = !state.isMuted;
                
                if (state.room && state.room.localParticipant) {
                    state.room.localParticipant.setMicrophoneEnabled(!state.isMuted);
                }
                
                if (state.isMuted) {
                    elements.muteIcon.innerHTML = '<line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/>';
                    elements.muteBtn.classList.add('active');
                } else {
                    elements.muteIcon.innerHTML = '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>';
                    elements.muteBtn.classList.remove('active');
                }
            }
            
            function showModal() {
                elements.modalOverlay.classList.add('visible');
            }
            
            function hideModal() {
                elements.modalOverlay.classList.remove('visible');
            }
            
            function confirmEndInterview() {
                hideModal();
                if (state.room) {
                    state.room.disconnect();
                }
            }
            
            async function connectToRoom() {
                updateStatus('Requesting access...', 'connecting');
                
                try {
                    var tokenData = {
                        name: candidate.name,
                        email: candidate.email,
                        role: candidate.role,
                        level: candidate.level,
                        resumeCacheKey: candidate.resumeCacheKey,
                        includeProfile: candidate.includeProfile
                    };
                    
                    // Add JD from session storage
                    var jd = sessionStorage.getItem('mockflow_jd');
                    if (jd) {
                        tokenData.jobDescription = jd;
                        sessionStorage.removeItem('mockflow_jd');
                    }
                    
                    var response = await fetch('/api/token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(tokenData)
                    });
                    
                    var data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    // Store room name for feedback URL generation
                    state.roomName = data.room;
                    
                    updateStatus('Connecting to room...', 'connecting');
                    
                    state.room = new LK.Room({
                        adaptiveStream: true,
                        dynacast: true,
                        audioCaptureDefaults: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    state.room.on(LK.RoomEvent.Connected, onConnected);
                    state.room.on(LK.RoomEvent.Disconnected, onDisconnected);
                    state.room.on(LK.RoomEvent.TrackSubscribed, onTrackSubscribed);
                    state.room.on(LK.RoomEvent.DataReceived, onDataReceived);
                    state.room.on(LK.RoomEvent.ParticipantConnected, onParticipantConnected);
                    state.room.on(LK.RoomEvent.LocalTrackPublished, onLocalTrackPublished);
                    
                    await state.room.connect(data.url, data.token);
                    
                } catch (err) {
                    console.error('[CONNECT] Error:', err);
                    updateStatus('Connection failed: ' + err.message, 'error');
                }
            }
            
            async function onConnected() {
                console.log('[ROOM] Connected');
                state.isConnected = true;
                updateStatus('Connected', 'connected');

                try {
                    await state.room.localParticipant.setMicrophoneEnabled(true);
                    console.log('[ROOM] Microphone enabled');

                    var audioTracks = state.room.localParticipant.getTrackPublications();
                    var visualizationInitialized = false;

                    audioTracks.forEach(function(pub) {
                        if (pub.track && pub.track.kind === 'audio' && pub.track.mediaStream) {
                            initCandidateAudioVisualization(pub.track.mediaStream);
                            visualizationInitialized = true;
                            console.log('[AUDIO] Candidate visualization initialized from existing track');
                        }
                    });

                    if (!visualizationInitialized) {
                        console.log('[AUDIO] Waiting for LocalTrackPublished event for visualization');
                    }

                    updateCandidateCaption('Waiting for agent to join...');

                } catch (err) {
                    console.error('[ROOM] Microphone error:', err);
                    updateStatus('Microphone access denied', 'error');
                }
            }

            function onLocalTrackPublished(publication, participant) {
                console.log('[TRACK] Local track published:', publication.kind);

                if (publication.kind === LK.Track.Kind.Audio && publication.track) {
                    console.log('[AUDIO] Initializing candidate visualization with local audio track');

                    if (publication.track.mediaStream) {
                        initCandidateAudioVisualization(publication.track.mediaStream);
                        console.log('[AUDIO] Candidate audio visualization started');
                    } else if (publication.track.mediaStreamTrack) {
                        var stream = new MediaStream([publication.track.mediaStreamTrack]);
                        initCandidateAudioVisualization(stream);
                        console.log('[AUDIO] Candidate audio visualization started (from MediaStreamTrack)');
                    }
                }
            }

            function initCandidateAudioVisualization(stream) {
                try {
                    stopDemoAnimations();

                    if (state.audioContext) {
                        state.audioContext.close();
                    }

                    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    if (state.audioContext.state === 'suspended') {
                        state.audioContext.resume();
                    }

                    state.analyser = state.audioContext.createAnalyser();
                    state.analyser.fftSize = 256;
                    state.analyser.smoothingTimeConstant = 0.3;
                    state.analyser.minDecibels = -90;
                    state.analyser.maxDecibels = -10;

                    var source = state.audioContext.createMediaStreamSource(stream);
                    source.connect(state.analyser);

                    console.log('[AUDIO] Candidate visualization initialized, fftSize:', state.analyser.fftSize);
                    drawCandidateWaveform();
                } catch (err) {
                    console.error('[AUDIO] Candidate visualization error:', err);
                }
            }

            function drawCandidateWaveform() {
                if (!state.analyser) {
                    console.log('[AUDIO] No analyser available');
                    return;
                }

                var bufferLength = state.analyser.frequencyBinCount;
                var dataArray = new Uint8Array(bufferLength);

                function draw() {
                    requestAnimationFrame(draw);

                    state.analyser.getByteTimeDomainData(dataArray);

                    var amplitudes = new Uint8Array(SPIKE_COUNT);
                    var samplesPerSpike = Math.floor(bufferLength / SPIKE_COUNT);

                    for (var i = 0; i < SPIKE_COUNT; i++) {
                        var sum = 0;
                        var startIdx = i * samplesPerSpike;
                        for (var j = 0; j < samplesPerSpike; j++) {
                            var sample = Math.abs(dataArray[startIdx + j] - 128);
                            sum += sample;
                        }
                        amplitudes[i] = (sum / samplesPerSpike) * 2;
                    }

                    updateCandidateSpikes(amplitudes);
                }

                draw();
            }
            
            function onDisconnected(reason) {
                state.isConnected = false;
                updateStatus('Disconnected', 'disconnected');
                
                if (state.timerInterval) clearInterval(state.timerInterval);
                if (state.blinkInterval) clearTimeout(state.blinkInterval);
                
                setTimeout(function() {
                    showInterviewCompleteModal();
                }, 1000);
            }
            
            function showInterviewCompleteModal() {
                document.getElementById('modalTitle').textContent = 'Interview Complete';
                document.getElementById('modalMessage').textContent = 'Thank you for participating! Would you like to get feedback on your interview?';
                document.getElementById('modalIcon').className = 'modal-icon success';
                document.getElementById('modalIcon').innerHTML = '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>';
                
                // Hide the confirm/cancel actions, show feedback actions
                document.getElementById('modalActions').style.display = 'none';
                document.getElementById('modalFeedbackActions').style.display = 'flex';
                
                // Set up feedback button
                var feedbackBtn = document.getElementById('getFeedbackBtn');
                feedbackBtn.onclick = function() {
                    var filename = getInterviewFilename();
                    if (filename) {
                        window.location.href = '/feedback/' + encodeURIComponent(filename) + '?request_feedback=1';
                    } else {
                        // Fallback to past calls page
                        window.location.href = '/past-calls';
                    }
                };
                
                // Set up return home button
                document.getElementById('returnHomeBtn').onclick = function() {
                    window.location.href = '/';
                };
                
                showModal();
            }
            
            function getInterviewFilename() {
                // Generate expected filename based on candidate name and timestamp
                if (state.interviewFilename) {
                    return state.interviewFilename;
                }
                
                // Build filename from candidate info and room connection time
                var name = candidate.name.toLowerCase().replace(/\s+/g, '_');
                var now = new Date();
                var dateStr = now.getFullYear().toString() +
                    (now.getMonth() + 1).toString().padStart(2, '0') +
                    now.getDate().toString().padStart(2, '0') + '_' +
                    now.getHours().toString().padStart(2, '0') +
                    now.getMinutes().toString().padStart(2, '0') +
                    now.getSeconds().toString().padStart(2, '0');
                
                return name + '_' + dateStr + '.json';
            }
            
            function onTrackSubscribed(track, publication, participant) {
                console.log('[TRACK] Subscribed to track:', track.kind);

                if (track.kind === LK.Track.Kind.Audio) {
                    var audioElement = track.attach();
                    audioElement.volume = 1.0;
                    document.body.appendChild(audioElement);

                    console.log('[AUDIO] Agent audio attached, initializing visualization');
                    initAgentAudioVisualization(track);
                    updateAgentCaption('Agent connected. Interview starting...');
                }
            }

            function initAgentAudioVisualization(track) {
                try {
                    if (state.agentAudioContext) {
                        state.agentAudioContext.close();
                    }

                    state.agentAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                    if (state.agentAudioContext.state === 'suspended') {
                        state.agentAudioContext.resume();
                    }

                    state.agentAudioAnalyser = state.agentAudioContext.createAnalyser();
                    state.agentAudioAnalyser.fftSize = 256;
                    state.agentAudioAnalyser.smoothingTimeConstant = 0.3;
                    state.agentAudioAnalyser.minDecibels = -90;
                    state.agentAudioAnalyser.maxDecibels = -10;

                    var source = state.agentAudioContext.createMediaStreamSource(track.mediaStream);
                    source.connect(state.agentAudioAnalyser);

                    console.log('[AUDIO] Agent visualization initialized with frequency data');
                    drawAgentWaveform();
                } catch (err) {
                    console.error('[AUDIO] Agent visualization error:', err);
                }
            }

            function drawAgentWaveform() {
                if (!state.agentAudioAnalyser) {
                    console.log('[AUDIO] No agent analyser available');
                    return;
                }

                var bufferLength = state.agentAudioAnalyser.frequencyBinCount;
                var frequencyData = new Uint8Array(bufferLength);

                function draw() {
                    requestAnimationFrame(draw);

                    state.agentAudioAnalyser.getByteFrequencyData(frequencyData);

                    var totalEnergy = 0;
                    for (var i = 0; i < frequencyData.length; i++) {
                        totalEnergy += frequencyData[i];
                    }

                    updateAgentVisualizer(frequencyData);

                    var avgEnergy = totalEnergy / bufferLength;
                    setAgentSpeaking(avgEnergy > 15);
                }

                draw();
            }

            function setAgentSpeaking(speaking) {
                if (speaking) {
                    elements.agentVisualizer.classList.add('speaking');
                } else {
                    elements.agentVisualizer.classList.remove('speaking');
                }
            }
            
            function onDataReceived(payload, participant) {
                try {
                    var data = JSON.parse(new TextDecoder().decode(payload));
                    
                    if (data.type === 'stage_change' && data.stage) {
                        updateStage(data.stage);
                    }
                    
                    if (data.type === 'agent_caption') {
                        updateAgentCaption(data.text);
                    }
                    
                    if (data.type === 'user_caption') {
                        updateCandidateCaption(data.text);
                    }
                    
                    if (data.type === 'interview_ending') {
                        updateAgentCaption('Interview complete.');
                        updateStatus('Interview Complete', 'connected');
                        
                        setTimeout(function() {
                            showInterviewCompleteModal();
                        }, 2000);
                    }
                } catch (err) {
                    console.error('[DATA] Parse error:', err);
                }
            }
            
            function onParticipantConnected(participant) {
                console.log('[PARTICIPANT] Connected:', participant.identity);
            }
        }
    })();
    </script>
</body>
</html>